{"title":"Es6学习笔记：这就是This （上）","date":"2019-05-01T11:57:17.000Z","link":"post/Es6之关于this （上）","tags":["css","es6","js","前端"],"updated":"2019-05-05T12:31:31.000Z","content":"<h2 id=\"Es6之关于this-（上）\">Es6之关于<code>this</code>  （上）<a href=\"post/Es6之关于this （上）#Es6之关于this-（上）\"></a></h2><p>资料参考：</p>\n<p>​        -     MDN</p>\n<p>​        -     你不知道的js上卷</p>\n<p>​        -     <a href=\"https://github.com/mqyqingfeng/Blog/issues/3\" target=\"_blank\" rel=\"noopener\">冯羽</a></p>\n<pre><code>-     [林鑫](https://github.com/lin-xin/blog/issues/7)\n</code></pre><h3 id=\"前言介绍\">前言介绍<a href=\"post/Es6之关于this （上）#前言介绍\"></a></h3><p><code>this</code>关键字是JavaScript中最复杂的机制之一，它是一个特别的关键字，被自动定义在所有函数的作用域中。但是即使是非常有经验的JavaScript开发者也很难说清他到底指向什么</p>\n<p>——Arthur C. Clarke</p>\n<p>全局环境下任何在函数体外部的<code>this</code>都指向全局对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在浏览器中, window 对象同时也是全局对象：</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">37</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.a); <span class=\"comment\">// 37</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.b = <span class=\"string\">\"MDN\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.b)  <span class=\"comment\">// \"MDN\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b)         <span class=\"comment\">// \"MDN\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对This的误解\">对This的误解<a href=\"post/Es6之关于this （上）#对This的误解\"></a></h3><p>我们很容易把<code>this</code>理解为指向函数自身，从<code>this</code>的字面意思可以这么理解</p>\n<p>实际上是这样的吗我们可以看一下MDN上的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"string\">'Custom'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个属性是在global对象定义的。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'Global'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">whatsThis</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;  <span class=\"comment\">// this的值取决于函数的调用方式</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">whatsThis();          <span class=\"comment\">// 'Global'</span></span><br><span class=\"line\">whatsThis.call(obj);  <span class=\"comment\">// 'Custom'</span></span><br><span class=\"line\">whatsThis.apply(obj); <span class=\"comment\">// 'Custom'</span></span><br></pre></td></tr></table></figure>\n<p>我们把它复制到浏览器中测试一下是否如此。结果是当然的</p>\n<p>可以看出this的值是取决于函数调用的方式这是不是非常有趣</p>\n<p>我们再来看一个例子//来自你不知道的JavaScript上卷</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(<span class=\"string\">'foo :'</span> + num)</span><br><span class=\"line\">\t  <span class=\"keyword\">this</span>.conut++\t<span class=\"comment\">//记录被调用次数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">    foo(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count)<span class=\"comment\">//foo被调用了多少次呢？</span></span><br></pre></td></tr></table></figure>\n<p>打印后发现这并不是我们想要的值，虽然属性名相同但是它打印的并不是函数里头的<code>conut</code>所以打印出来是0⃣️</p>\n<p><strong>一般人会这样解决请看下面</strong> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data =&#123;</span><br><span class=\"line\">\tcount: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的确能把调用次数打印出来，涉及词法作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">作用域是指程序源代码中定义变量的区域。</span><br><span class=\"line\"></span><br><span class=\"line\">作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript采用词法作用域（lexical scoping），也就是静态作用域。</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态作用域与动态作用域\">静态作用域与动态作用域<a href=\"post/Es6之关于this （上）#静态作用域与动态作用域\"></a></h2><p>因为JavaScript采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>\n<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>\n<p>让我们认真看个例子就能明白之间的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value =  <span class=\"number\">1</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">foo</span>（）</span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>。log（value）;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">bar</span>（）</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> value =  <span class=\"number\">2</span> ;</span><br><span class=\"line\">    foo（）;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar（）;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果是???</span></span><br></pre></td></tr></table></figure>\n<p>假设JavaScript的采用静态作用域，让我们分析下执行过程：</p>\n<p>执行FOO函数，先从FOO函数内部查找是否有局部变量值，如果没有，就根据书写的位置，查找上面一层的代码，也就是值等于1，所以结果会打印1。</p>\n<p>假设的JavaScript采用动态作用域，让我们分析下执行过程：</p>\n<p>执行FOO函数，依然是从富函数内部查找是否有局部变量值。如果没有，就从调用函数的作用域，也就是杆函数内部查找值变量，所以结果会打印2。</p>\n<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是1。</p>\n<h2 id=\"动态作用域\">动态作用域<a href=\"post/Es6之关于this （上）#动态作用域\"></a></h2><p>也许你会好奇什么语言是动态作用域？</p>\n<p>bash就是动态作用域，不信的话，把下面的脚本存成例如scope.bash，然后进入相应的目录，用命令行执行<code>bash ./scope.bash</code>，看看打印的值是多少。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value = <span class=\"number\">1</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">foo</span>（）</span>&#123;</span><br><span class=\"line\">     echo  $ value ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">bar</span>（）</span>&#123;</span><br><span class=\"line\">     local value = <span class=\"number\">2</span> ; </span><br><span class=\"line\">    foo ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">酒吧</span><br></pre></td></tr></table></figure>\n<p><strong>This</strong>及不指向函数自身也不指向函数的语法作用域</p>\n<p><strong>This</strong> 实际上是在函数被调用时发生的绑定，他指向什么完全取决于函数在哪里调用。</p>\n<h2 id=\"Call\">Call<a href=\"post/Es6之关于this （上）#Call\"></a></h2><p>一句话介绍 call：</p>\n<blockquote>\n<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>\n<p>apply 的实现跟 call 类似</p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    value: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar.call(foo); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>注意两点：</p>\n<ol>\n<li>call 改变了 this 的指向，指向到 foo</li>\n<li>bar 函数执行了</li>\n</ol>\n<h3 id=\"详解\">详解<a href=\"post/Es6之关于this （上）#详解\"></a></h3><h3 id=\"apply\">apply( )<a href=\"post/Es6之关于this （上）#apply\"></a></h3><p>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;linxin&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function func(firstName, lastName)&#123;</span><br><span class=\"line\">    console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func.apply(obj, [&apos;A&apos;, &apos;B&apos;]);    // A linxin B</span><br></pre></td></tr></table></figure>\n<p>可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。</p>\n<h3 id=\"call\">call( )<a href=\"post/Es6之关于this （上）#call\"></a></h3><p>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'linxin'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">firstName, lastName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">' '</span> + lastName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(obj, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>);       <span class=\"comment\">// C linxin D</span></span><br></pre></td></tr></table></figure>\n<p>对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。</p>\n<p>对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。</p>\n","prev":{"title":"Bootstrap入门","link":"post/demo-1-grid"},"next":{"title":"Es6学习笔记：箭头函数","link":"post/ES6之箭头函数"},"plink":"http://yoursite.com/post/Es6之关于this （上）/","toc":[{"title":"Es6之关于<code>this</code>  （上）","id":"Es6之关于this-（上）","index":"1","children":[{"title":"前言介绍","id":"前言介绍","index":"1.1"},{"title":"对This的误解","id":"对This的误解","index":"1.2"}]},{"title":"静态作用域与动态作用域","id":"静态作用域与动态作用域","index":"2"},{"title":"动态作用域","id":"动态作用域","index":"3"},{"title":"Call","id":"Call","index":"4","children":[{"title":"apply( )","id":"apply","index":"4.1"},{"title":"call( )","id":"call","index":"4.2"}]}]}